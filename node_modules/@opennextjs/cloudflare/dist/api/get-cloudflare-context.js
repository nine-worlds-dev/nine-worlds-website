// Note: this symbol needs to be kept in sync with the one used in `src/cli/templates/worker.ts`
const cloudflareContextSymbol = Symbol.for("__cloudflare-context__");
/**
 * Utility to get the current Cloudflare context
 *
 * @returns the cloudflare context
 */
export async function getCloudflareContext() {
    const global = globalThis;
    const cloudflareContext = global[cloudflareContextSymbol];
    if (!cloudflareContext) {
        // the cloudflare context is initialized by the worker and is always present in production/preview,
        // so, it not being present means that the application is running under `next dev`
        return getCloudflareContextInNextDev();
    }
    return cloudflareContext;
}
const cloudflareContextInNextDevSymbol = Symbol.for("__next-dev/cloudflare-context__");
/**
 * Gets a local proxy version of the cloudflare context (created using `getPlatformProxy`) when
 * running in the standard next dev server (via `next dev`)
 *
 * @returns the local proxy version of the cloudflare context
 */
async function getCloudflareContextInNextDev() {
    const global = globalThis;
    if (!global[cloudflareContextInNextDevSymbol]) {
        // Note: we never want wrangler to be bundled in the Next.js app, that's why the import below looks like it does
        const { getPlatformProxy } = await import(
        /* webpackIgnore: true */ `${"__wrangler".replaceAll("_", "")}`);
        const { env, cf, ctx } = await getPlatformProxy({
            // This allows the selection of a wrangler environment while running in next dev mode
            environment: process.env.NEXT_DEV_WRANGLER_ENV,
        });
        global[cloudflareContextInNextDevSymbol] = {
            env,
            cf: cf,
            ctx: ctx,
        };
    }
    return global[cloudflareContextInNextDevSymbol];
}
